# 객체지향이란

> 객체끼리는 서로 **공존**하는 관계

* 현실세계에서는 **단방향**으로 접근
```
사람 ➡️ 자동차: 단지 도구의 역할
```
* 객체지향의 세계에서는 **양방향**으로 접근(**요청 ↔️ 응답**)
```
사람 ➡️ 자동차: 엑셀 밟기 요청
자동차 ➡️ 사람: 가속 응답(기름 소모)
```

# 객체지향 프로그래밍
## 책임주도설계

> 객체는 **책임**을 나눠갖도록 설계해야 한다.

![책임주도설계](https://velog.velcdn.com/images/1998/post/058a8fdc-8139-491c-9ca4-43b773476ebe/image.png)

* 사람(객체)의 책임: 주유 행동, 가속 요청
* 자동차(객체)의 책임: 주유 요청, 사람으로부터 가속 요청 시 응답
* 주유소(객체)의 책임: 사람으로부터 주유 요청 시 응답

**즉, 책임주도 설계란 각 객체에게 책임을 부여해서 적절하게 상호작용할 수 있도록 설계하는 것.**


## 역할과 구현

>💡 자동차 객체를 버스에 맞춰 구현했는데 트럭이 필요하다면?

**역할(큰 틀)을 중심으로 구현**
자동차(역할) > 굴러감(책임) > 승용차, 트럭, 버스(구현)

```
승용차, 트럭, 버스의 공통적인 역할: 엑셀, 전진, 후진, 기름…
```

**추후에 제한사항이 생길 수 있으므로 공통적인 역할 먼저, 세부적인 건 나중에 구현**
원하는 기능만을 통해서 자율성을 가질 수 있도록 객체에게 맞는 책임을 잘 부여해야 함.
잘 만들어진 객체지향은 신뢰할 수 있음.

## 객체지향 프로그래밍의 4가지 특징
**1. 추상화**

**2. 캡슐화**
* 한 부분이 망가져도 전체적인 서비스에는 영향이 없게끔 결합도는 낮게 설계해야 한다.

**3. 상속**

**4. 다형성**
* 메서드 오버라이딩: 상위 → 하위 재정의
* 메서드 오버로딩: 같은 이름의 메서드 → 상황에 따라 다른 기능

## 객체지향 설계원칙, SOLID
**1. 단일 책임 원칙(SRP, Single Responsibility Principle)**
* 하나의 클래스는 하나의 책임만을 가져야 한다.

**2. 개방-폐쇄 원칙(OCP, Open-closed Principle)**
* 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
* 기능을 변경하거나 확장할 수 있으면서 기능을 사용하는 코드는 수정하지 않는다.

**3. 리스코프 치환 원칙(LSP, Liskov Substitution Principle)**
* 객체는 프로그램의 정확성을 깨지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
* 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입의 프로그램은 정상 작동해야 한다.

**4. 인터페이스 분리 원칙(ISP, Interface Segregation Principle)**
* 하나의 인터페이스보다 여러 개의 인터페이스로 분리하는 것이 좋다.
* 인터페이스는 사용자(클라이언트)를 기준으로 분리해야 한다.

**5. 의존관계 역전 원칙(DIP, Dependency Inversion Principle)**
* 추상화가 아닌 구체화에 의존해서는 안된다.
* 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.
* 저수준 모듈의 고수준 모듈에서 정의한 추상 타입에 의존해야 한다.

