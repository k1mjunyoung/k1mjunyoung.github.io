---
layout: post
title:  "다이나믹하게 프로그래밍해보자"
subtitle: "피보나치 수열로 알아보는 DP"
type: "Tech"
blog: true
text: true
author: "Kim Jun Young"
post-header: true
header-img: "https://velog.velcdn.com/images/1998/post/2fdd77e7-39fe-44d4-a792-6f521b47329a/image.webp"
order: 3
date: 2023-11-27
toc: true
---

# 🧐 다이나믹 프로그래밍이란?

> **다이나믹 프로그래밍(Dynamic Programming, DP)**이란 하나의 문제를 단 한 번만 풀도록 하는 알고리즘이다.

일반적으로 분할 정복 기법은 동일한 문제를 다시 푼다는 단점을 가지고 있다. 단순 분할 정복으로 풀게 되면 심각한 비효율성을 낳는 대표적인 예시로는 피보나치 수열이 있다.

# 📜 피보나치 수열과 분할 정복

피보나치 수열은 **특정한 숫자를 구하기 위해 그 앞에 있는 숫자와 두 칸 앞에 있는 숫자의 합**을 구해야 한다.

> 피보나치 수열 점화식: `D[i] = D[i-1] + D[i-2]`

피보나치 수열의 초기 값은 `1` 로 고정되므로 위 점화식에 적용하면 `1, 1, 2, 3, 5, 8, 13, 21, 34, 55, ...` 와 같이 나아갈 수 있다.
만약 단순 분할 정복 기법을 이용해 피보나치 수열을 푼다면 어떻게 될까?

![출처: https://blog.naver.com/ndb796/221233570962](https://velog.velcdn.com/images/1998/post/1392ab01-7f62-4f5b-87e5-30a623405193/image.png)

단순 분할 정복으로 피보나치 수열의 15번째 값인 `D[15]` 를 구하려면 `D[14]` 와 `D[13]` 을 계산해야 하고, `D[14]` 를 구하려면 `D[13]` 과 `D[12]` 를 계산해야 한다.
이렇게 단순한 분할 정복 기법을 사용하면 이미 수행한 계산를 또 반복적으로 수행하기 때문에 **굉장히!** 비효율적이게 된다.

아래는 단순하게 피보나치 수열을 구하는 과정을 JAVA로 구현한 코드이다.

```java
public class Main{
    static int fibo(int x){
        if(x == 1) return 1;
        if(x == 2) return 1;
        return fibo(x-1) + fibo(x-2);
    }
    
    public static void main(String[] args){
        System.out.println(fibo(10));
    }
}
```

위와 같이 `fybo` 메서드(함수)에 `10` 을 넣으면 피보나치 수열의 10번째 값인 `55` 가 잘 출력된다. **만약 `fybo` 메서드에 `50` 을 넣으면 어떻게 될까?**
.
.
.
_아마 우주가 멸망할 때까지 CPU가 달궈지고 결국엔 실행되지 않을 것이다..._😮

이는 사실 당연한 결과로, 피보나치 수열이 1개만 증가해도 **계산량은 2배로 늘어난다.** 위와 같은 방법으로 피보나치 수열의 50번째 값을 구하려면 2의 50제곱 즉, 1,000,000,000,000,000개가 넘는 계산량을 컴퓨터가 처리해야 한다는 것이다.

# 🔥 DP의 등장

다이나믹 프로그래밍은 다음의 두 가정 하에 사용할 수 있다.

> 1. 큰 문제를 작은 문제로 나눌 수 있다.
> 2. 작은 문제에서 구한 정답이 그 문제를 포함하는 큰 문제에서도 동일하다.

쉽게 말해, 크고 어려운 문제를 잘게 나누어 해결한 뒤에 전체의 답을 구하는 방법이다. 다만 이 과정에서 분할 정복과 다른 점은 **메모이제이션(Memoization)**이 사용된다는 것이다. <u>이미 계산한 결과는 배열에 저장함으로써</u> 나중에 동일한 계산을 해야 할 때 배열에서 꺼내오기만 하면 된다.

## 📝 메모이제이션
> **메모이제이션(Memoization)**이란 동일한 계산을 반복해야 할 때 <u>이미 계산한 결과를 메모리(배열)에 저장</u>해 두었다가 필요할 때 꺼내 씀으로써 중복 계산을 방지할 수 있게 하는 기법이다.

다이나믹 프로그래밍의 메모이제이션 기법을 활용하면 우주멸망을 막을 수 있다(?)

```java
public class Main{
    static int[] d = new int[100];

    static int fibo(int x){
        if(x == 1) return 1;
        if(x == 2) return 1;
        if(d[x] != 0) return d[x];
        return d[x] = fibo(x-1) + fibo(x-2);
    }
    
    public static void main(String[] args){
        System.out.println(fibo(30));
    }
}
```

위의 코드는 다이나믹 프로그래밍의 메모이제이션 기법을 활용해 작성한 JAVA 코드이다.

이미 계산된 결과는 배열 `d` 에 저장되기 때문에 한 번 구한 값을 다시 계산하는 일은 없으므로 **순식간에!** 피보나치 수열의 30번째 값이 구해지는 것을 볼 수 있다.(50번째 값은 매우 크기 때문에 오버플로우가 발생하여 음수값이 나온다. 알고 싶다면 `int` 타입 대신 `long` 타입을 사용하자)

# 마무리
[백준 1463번](https://www.acmicpc.net/problem/1463)을 다이나믹하게 풀어보아요
## ref
* <a href="https://www.google.com/" target="_blank">[이것이 코딩테스트다] 저자, 나동빈님 블로그</a>